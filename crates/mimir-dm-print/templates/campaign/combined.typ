// Mimir Print System - Combined Campaign Export Template
// Renders all campaign documents as a single PDF with cover and table of contents

#import "/_shared/styles.typ": *
#import "/_shared/components.typ": stat-block, monster-card-inline, ability-mod

// Expected data structure (injected by PrintService):
// - campaign_name: Name of the campaign (string)
// - documents: Array of document objects, each with:
//   - title: Document title
//   - document_type: Type (e.g., "session_outline")
//   - content: Pre-converted Typst content
// - modules: Array of module objects (optional), each with:
//   - name: Module name
//   - module_number: Module number
//   - monsters: Array of monster data objects

#let campaign-name = data.at("campaign_name", default: "Campaign Documents")
#let documents-raw = data.at("documents", default: ())
#let documents = if documents-raw == none { () } else { documents-raw }
#let modules-raw = data.at("modules", default: ())
#let modules = if modules-raw == none { () } else { modules-raw }

// Format document type for display
#let format-type(doc-type) = {
  doc-type.replace("_", " ").split(" ").map(word => {
    if word.len() > 0 {
      upper(word.at(0)) + word.slice(1)
    } else {
      word
    }
  }).join(" ")
}

// Group documents by type
#let group-documents(docs) = {
  let groups = (:)
  for doc in docs {
    let doc-type = doc.at("document_type", default: "other")
    if doc-type not in groups {
      groups.insert(doc-type, ())
    }
    groups.at(doc-type).push(doc)
  }
  groups
}

// Base page setup (no header/footer for cover page)
#set page(
  paper: "us-letter",
  margin: (top: 1in, bottom: 0.75in, left: 0.75in, right: 0.75in),
)

// Base text settings
#set text(
  font: font-body,
  size: sizes.base,
  fill: colors.text,
)

// Heading styles
#show heading.where(level: 1): it => {
  v(spacing.lg)
  text(size: sizes.xxl, weight: "bold", font: font-heading, it.body)
  v(spacing.md)
}

#show heading.where(level: 2): it => {
  v(spacing.md)
  text(size: sizes.xl, weight: "bold", font: font-heading, it.body)
  v(spacing.sm)
}

#show heading.where(level: 3): it => {
  v(spacing.sm)
  text(size: sizes.lg, weight: "bold", font: font-heading, it.body)
  v(spacing.xs)
}

// Paragraph settings
#set par(
  leading: 0.65em,
  justify: true,
  first-line-indent: 0pt,
)

// List settings
#set list(
  indent: 1em,
  body-indent: 0.5em,
)

#set enum(
  indent: 1em,
  body-indent: 0.5em,
)

// Blockquote styling
#show quote: it => {
  block(
    width: 100%,
    inset: (left: 1em, y: 0.5em),
    stroke: (left: 2pt + colors.border-light),
    fill: colors.background-alt,
  )[
    #set text(style: "italic")
    #it.body
  ]
}

// =============================================================================
// COVER PAGE (only shown when there are campaign-level documents)
// =============================================================================

#if documents.len() > 0 [
  #align(center + horizon)[
    #v(2in)

    #text(size: 36pt, weight: "bold", font: font-heading, campaign-name)

    #v(1in)

    #text(size: sizes.xl, fill: colors.text-secondary)[Campaign Documents]

    #v(2in)

    #line(length: 3in, stroke: 1pt + colors.border-light)

    #v(0.5in)

    #text(size: sizes.sm, fill: colors.text-secondary)[Generated by Mimir]
  ]

  #pagebreak()

  // ===========================================================================
  // TABLE OF CONTENTS
  // ===========================================================================

  = Table of Contents

  #v(spacing.lg)

  #for (i, doc) in documents.enumerate() [
    #let doc-title = doc.at("title", default: "Untitled")
    #let doc-type = doc.at("document_type", default: "document")
    #let formatted-type = format-type(doc-type)
    // Only show type if it's not redundant with the title
    #let show-type = not doc-title.contains(formatted-type) and formatted-type != doc-title

    #grid(
      columns: (1fr, auto),
      gutter: spacing.sm,
      [#str(i + 1). #doc-title],
      if show-type [#text(size: sizes.sm, fill: colors.text-secondary)[#formatted-type]] else []
    )
    #v(spacing.xs)
  ]

  #pagebreak()
]

// =============================================================================
// DOCUMENT PAGES
// =============================================================================

#for (i, doc) in documents.enumerate() [
  #let doc-title = doc.at("title", default: "Untitled")
  #let doc-type = doc.at("document_type", default: "document")
  #let content = doc.at("content", default: "")

  // Document type badge
  #set text(size: sizes.sm, fill: colors.text-secondary)
  #format-type(doc-type)

  // Document title
  #v(spacing.sm)
  #align(center)[
    #text(size: sizes.title, weight: "bold", font: font-heading, doc-title)
  ]

  #v(spacing.lg)

  // Document content
  #set text(size: sizes.base, fill: colors.text)
  #eval(content, mode: "markup")

  // Page break between documents (except after last)
  #if i < documents.len() - 1 [
    #pagebreak()
  ]
]

// =============================================================================
// MODULE MONSTER CARDS
// =============================================================================

// Helper to parse monster entries
#let parse-entries(entries) = {
  if entries == none { return () }
  entries.map(entry => {
    if type(entry) == str { (name: none, description: entry) } else if type(entry) == dictionary {
      let name = entry.at("name", default: none)
      let entry-entries-raw = entry.at("entries", default: ())
      let entry-entries = if entry-entries-raw == none { () } else { entry-entries-raw }
      let desc = if entry-entries.len() > 0 { entry-entries.filter(e => type(e) == str).join(" ") } else { "" }
      (name: name, description: desc)
    } else { (name: none, description: str(entry)) }
  }).filter(e => e.description != "" or e.name != none)
}

// Helper to extract monster data
#let extract-monster-data(monster) = {
  let monster-name = monster.at("name", default: "Unknown Monster")
  let quantity = monster.at("quantity", default: 1)
  let encounter-tag = monster.at("encounter_tag", default: none)

  // Size
  let size-data-raw = monster.at("size", default: ("M",))
  let size-data = if size-data-raw == none { ("M",) } else { size-data-raw }
  let monster-size = {
    if type(size-data) == array and size-data.len() > 0 {
      let s = size-data.at(0)
      if s == "T" { "Tiny" } else if s == "S" { "Small" } else if s == "M" { "Medium" } else if s == "L" { "Large" } else if s == "H" { "Huge" } else if s == "G" { "Gargantuan" } else { s }
    } else if type(size-data) == str { size-data } else { "Medium" }
  }

  // Type
  let type-data = monster.at("creature_type", default: "humanoid")
  let monster-type = {
    if type(type-data) == str { type-data } else if type(type-data) == dictionary {
      let base = type-data.at("type", default: "humanoid")
      let tags-raw = type-data.at("tags", default: ())
      let tags = if tags-raw == none { () } else { tags-raw }
      if tags.len() > 0 { base + " (" + tags.join(", ") + ")" } else { base }
    } else { "humanoid" }
  }

  // Alignment
  let align-data = monster.at("alignment", default: none)
  let monster-alignment = {
    if align-data == none { "unaligned" } else if type(align-data) == array {
      let abbrevs = align-data.map(a => {
        if type(a) == str {
          if a == "L" { "lawful" } else if a == "N" { "neutral" } else if a == "NX" { "neutral" } else if a == "NY" { "neutral" } else if a == "C" { "chaotic" } else if a == "G" { "good" } else if a == "E" { "evil" } else if a == "U" { "unaligned" } else if a == "A" { "any alignment" } else { a }
        } else { str(a) }
      })
      abbrevs.join(" ")
    } else if type(align-data) == str { align-data } else { "unaligned" }
  }

  // AC
  let ac-data = monster.at("ac", default: 10)
  let monster-ac = {
    if type(ac-data) == int { str(ac-data) } else if type(ac-data) == array and ac-data.len() > 0 {
      let first = ac-data.at(0)
      if type(first) == int { str(first) } else if type(first) == dictionary {
        let ac-val = first.at("ac", default: 10)
        let ac-from-raw = first.at("from", default: ())
        let ac-from = if ac-from-raw == none { () } else { ac-from-raw }
        if ac-from.len() > 0 { str(ac-val) } else { str(ac-val) }
      } else { "10" }
    } else { "10" }
  }

  // HP
  let hp-data = monster.at("hp", default: none)
  let monster-hp = {
    if hp-data == none { "1" } else if type(hp-data) == int { str(hp-data) } else if type(hp-data) == dictionary {
      let avg = hp-data.at("average", default: 1)
      str(avg)
    } else { "1" }
  }

  // Speed (simplified)
  let speed-data = monster.at("speed", default: none)
  let monster-speed = {
    if speed-data == none { "30 ft." } else {
      let walk = speed-data.at("walk", default: none)
      if walk != none and type(walk) == int { str(walk) + " ft." } else { "30 ft." }
    }
  }

  // Ability scores
  let str-score = monster.at("str", default: 10)
  let dex-score = monster.at("dex", default: 10)
  let con-score = monster.at("con", default: 10)
  let int-score = monster.at("int", default: 10)
  let wis-score = monster.at("wis", default: 10)
  let cha-score = monster.at("cha", default: 10)

  // CR
  let cr-data = monster.at("cr", default: "0")
  let monster-cr = {
    if type(cr-data) == str { cr-data } else if type(cr-data) == dictionary { cr-data.at("cr", default: "0") } else if type(cr-data) == int { str(cr-data) } else { "0" }
  }

  // Actions
  let actions = parse-entries(monster.at("action", default: ()))

  (
    name: monster-name,
    size: monster-size,
    type: monster-type,
    alignment: monster-alignment,
    ac: monster-ac,
    hp: monster-hp,
    speed: monster-speed,
    str: str-score,
    dex: dex-score,
    con: con-score,
    int: int-score,
    wis: wis-score,
    cha: cha-score,
    cr: monster-cr,
    quantity: quantity,
    encounter-tag: encounter-tag,
    actions: actions,
  )
}

// Track if we've rendered any content yet (for conditional pagebreak)
#let has-campaign-docs = documents.len() > 0

#for (module-index, module) in modules.enumerate() [
  #let module-name = module.at("name", default: "Unknown Module")
  #let module-number = module.at("module_number", default: 0)
  #let module-docs-raw = module.at("documents", default: ())
  #let module-docs = if module-docs-raw == none { () } else { module-docs-raw }
  #let monsters-raw = module.at("monsters", default: ())
  #let monsters = if monsters-raw == none { () } else { monsters-raw }

  // Separate session notes from other documents
  #let session-notes = module-docs.filter(doc => doc.at("document_type", default: "") == "session_notes")
  #let other-docs = module-docs.filter(doc => doc.at("document_type", default: "") != "session_notes")

  #if other-docs.len() > 0 or session-notes.len() > 0 or monsters.len() > 0 [
    // Only add pagebreak if there's prior content (campaign docs or previous modules)
    #if has-campaign-docs or module-index > 0 [
      #pagebreak()
    ]

    // Module heading
    = Module #module-number: #module-name

    // Render module documents first (excluding session notes)
    #for doc in other-docs [
      #let doc-title = doc.at("title", default: "Untitled")
      #let doc-type = doc.at("document_type", default: "document")
      #let content = doc.at("content", default: "")

      #v(spacing.md)

      // Document type badge
      #set text(size: sizes.sm, fill: colors.text-secondary)
      #format-type(doc-type)

      // Document title
      #v(spacing.xs)
      #text(size: sizes.lg, weight: "bold", font: font-heading)[#doc-title]

      #v(spacing.md)

      // Document content
      #set text(size: sizes.base, fill: colors.text)
      #eval(content, mode: "markup")

      #v(spacing.lg)
    ]

    // Always render Module Play Notes page (for physical note-taking)
    #pagebreak()

    #text(size: sizes.xl, weight: "bold", font: font-heading)[Module Play Notes]

    #v(spacing.lg)

    #if session-notes.len() > 0 [
      // Render existing session notes content
      #for note in session-notes [
        #let note-title = note.at("title", default: "Session Notes")
        #let content = note.at("content", default: "")

        // Note title
        #text(size: sizes.lg, weight: "bold", font: font-heading)[#note-title]

        #v(spacing.md)

        // Note content
        #set text(size: sizes.base, fill: colors.text)
        #eval(content, mode: "markup")

        #v(spacing.lg)
      ]
    ] else [
      // Placeholder for handwritten notes
      #text(size: sizes.base, fill: colors.text-secondary, style: "italic")[Use this page to record notes during play.]

      #v(spacing.xl)

      // Ruled lines for note-taking
      #for i in range(20) [
        #line(length: 100%, stroke: 0.5pt + colors.border-light)
        #v(1.5em)
      ]
    ]

    // Then render monster cards on a separate page
    #if monsters.len() > 0 [
      #pagebreak()

      #text(size: sizes.lg, weight: "bold")[Module #module-number Monsters]

      #v(spacing.md)

      #for monster in monsters [
        #let m = extract-monster-data(monster)

        #monster-card-inline(
          name: m.name,
          size: m.size,
          type: m.type,
          alignment: m.alignment,
          ac: m.ac,
          hp: m.hp,
          speed: m.speed,
          str: m.str,
          dex: m.dex,
          con: m.con,
          int: m.int,
          wis: m.wis,
          cha: m.cha,
          cr: m.cr,
          quantity: m.quantity,
          encounter-tag: m.encounter-tag,
          actions: m.actions,
        )

        #v(spacing.md)
      ]
    ]
  ]
]

// =============================================================================
// NPC CHARACTER SHEETS
// =============================================================================

#let npcs-raw = data.at("npcs", default: ())
#let npcs = if npcs-raw == none { () } else { npcs-raw }

// Helper to calculate ability modifier
#let ability-mod-calc(score) = {
  calc.floor((score - 10) / 2)
}

// Helper to format modifier
#let fmt-mod(score) = {
  let mod = ability-mod-calc(score)
  if mod >= 0 { "+" + str(mod) } else { str(mod) }
}

// Calculate proficiency bonus from level
#let prof-bonus(level) = {
  if level <= 4 { 2 }
  else if level <= 8 { 3 }
  else if level <= 12 { 4 }
  else if level <= 16 { 5 }
  else { 6 }
}

#if npcs.len() > 0 [
  #pagebreak()

  = Campaign NPCs

  #v(spacing.md)

  #for (npc-index, npc) in npcs.enumerate() [
    #let char-name = npc.at("character_name", default: "Unknown NPC")
    #let level = npc.at("level", default: 1)
    #let race = npc.at("race", default: "Unknown")
    #let subrace = npc.at("subrace", default: none)
    #let background = npc.at("background", default: "Unknown")
    #let alignment = npc.at("alignment", default: none)
    #let classes = npc.at("classes", default: ())

    // NPC-specific fields
    #let npc-role = npc.at("npc_role", default: none)
    #let npc-location = npc.at("npc_location", default: none)
    #let npc-faction = npc.at("npc_faction", default: none)
    #let npc-notes = npc.at("npc_notes", default: none)

    // Build class string
    #let class-str = if classes.len() > 0 {
      classes.map(c => {
        let name = c.at("class_name", default: "?")
        let lvl = c.at("level", default: 0)
        let sub = c.at("subclass", default: none)
        if sub != none { [#name (#sub) #lvl] } else { [#name #lvl] }
      }).join(" / ")
    } else { "Commoner" }

    // Race string with subrace
    #let race-str = if subrace != none { [#subrace #race] } else { race }

    // Ability scores
    #let abilities = npc.at("abilities", default: (
      strength: 10,
      dexterity: 10,
      constitution: 10,
      intelligence: 10,
      wisdom: 10,
      charisma: 10,
    ))
    #let str-score = abilities.at("strength", default: 10)
    #let dex-score = abilities.at("dexterity", default: 10)
    #let con-score = abilities.at("constitution", default: 10)
    #let int-score = abilities.at("intelligence", default: 10)
    #let wis-score = abilities.at("wisdom", default: 10)
    #let cha-score = abilities.at("charisma", default: 10)

    // Combat stats
    #let max-hp = npc.at("max_hp", default: 10)
    #let speed = npc.at("speed", default: 30)
    #let base-ac = 10 + ability-mod-calc(dex-score)

    // NPC Card
    #block(
      width: 100%,
      stroke: 1pt + colors.border-light,
      radius: 4pt,
      inset: spacing.md,
      breakable: false,
    )[
      // Header
      #grid(
        columns: (1fr, auto),
        [
          #text(size: sizes.lg, weight: "bold", font: font-heading)[#char-name]
          #linebreak()
          #text(size: sizes.sm)[Level #level #race-str #class-str]
          #if background != "Unknown" or alignment != none [
            #linebreak()
            #text(size: sizes.sm, fill: colors.text-secondary)[
              #if background != "Unknown" [#background]
              #if alignment != none [, #alignment]
            ]
          ]
        ],
        [
          #box(
            fill: colors.accent,
            radius: 4pt,
            inset: (x: spacing.sm, y: spacing.xs),
          )[
            #text(fill: white, weight: "bold", size: sizes.sm)[NPC]
          ]
        ]
      )

      #v(spacing.sm)

      // Two-column layout for stats and info
      #grid(
        columns: (1fr, 1fr),
        column-gutter: spacing.lg,

        // Left column: Ability scores and combat
        [
          // Ability Scores Grid
          #text(weight: "bold", size: sizes.sm)[Ability Scores]
          #v(spacing.xs)
          #grid(
            columns: (1fr, 1fr, 1fr),
            row-gutter: spacing.xs,
            column-gutter: spacing.sm,
            [*STR* #str-score (#fmt-mod(str-score))],
            [*DEX* #dex-score (#fmt-mod(dex-score))],
            [*CON* #con-score (#fmt-mod(con-score))],
            [*INT* #int-score (#fmt-mod(int-score))],
            [*WIS* #wis-score (#fmt-mod(wis-score))],
            [*CHA* #cha-score (#fmt-mod(cha-score))],
          )

          #v(spacing.sm)

          // Combat Stats
          #text(weight: "bold", size: sizes.sm)[Combat]
          #v(spacing.xs)
          #grid(
            columns: (auto, auto, auto, auto),
            column-gutter: spacing.md,
            [*HP* #max-hp],
            [*AC* #base-ac],
            [*Speed* #speed ft],
            [*Prof* +#prof-bonus(level)],
          )
        ],

        // Right column: NPC Info
        [
          #if npc-role != none or npc-location != none or npc-faction != none [
            #text(weight: "bold", size: sizes.sm)[NPC Details]
            #v(spacing.xs)
            #if npc-role != none [
              *Role:* #npc-role #linebreak()
            ]
            #if npc-location != none [
              *Location:* #npc-location #linebreak()
            ]
            #if npc-faction != none [
              *Faction:* #npc-faction
            ]
          ]
        ],
      )

      // Notes section (full width if present)
      #if npc-notes != none [
        #v(spacing.sm)
        #text(weight: "bold", size: sizes.sm)[Notes]
        #v(spacing.xs)
        #text(size: sizes.sm, fill: colors.text-secondary)[#npc-notes]
      ]
    ]

    #v(spacing.md)

    // Page break between NPCs (except after last)
    #if npc-index < npcs.len() - 1 and calc.rem(npc-index + 1, 3) == 0 [
      #pagebreak()
    ]
  ]
]

// Footer on last page
#v(1fr)
#align(center)[
  #text(size: sizes.sm, fill: colors.text-secondary)[Generated by Mimir]
]
